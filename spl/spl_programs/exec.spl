// store user stack pointer
alias userSP R0;
userSP = SP;

alias currentPID R1;
currentPID = [SYSTEM_STATUS_TABLE + 1];

// set mode flag
[PROCESS_TABLE + currentPID*16 + 9] = 9;

// switch to kernel stack
[PROCESS_TABLE + currentPID*16 + 13] = SP;
SP = [PROCESS_TABLE + (currentPID * 16) + 11] * 512 - 1;


// get name of the file from user stack
alias file_name R2;
file_name = [ [PTBR + 2 * ((userSP - 4)/ 512)]*512 + (userSP-4)%512 ];

alias i R3;
i = 0;
while( i<60 ) do
    if( [INODE_TABLE + i*16 + 1] == file_name) then
        break;
    endif ;
    i = i+1;
endwhile ;

if( i==60 ) then
    [([PTBR + 2 * ((userSP - 1) / 512)] * 512) + ((userSP - 1) % 512)] = -1;
    [PROCESS_TABLE + currentPID*16 + 9] = 0;
    SP = userSP;
    ireturn;
else

    multipush(R0,R1,R2,R3);

    // exit process
    R1 = 3;
    R2 = [SYSTEM_STATUS_TABLE + 1];
    call PROCESS_MANAGER;

    multipop(R0,R1,R2,R3);

    alias UAPage R4;
    UAPage = [PROCESS_TABLE + currentPID*16 + 11];

    // reclaim same User Area Page for the new process
    [MEMORY_FREE_LIST + UAPage] = [MEMORY_FREE_LIST + UAPage] + 1;
    [SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1; // Mem free count

    SP = UAPage*512 - 1;

    [PROCESS_TABLE+ currentPID*16 + 4] = RUNNING;
    [PROCESS_TABLE+ currentPID*16 + 7] = i; // inode index

    // initialise per-process resource table
    alias k R5;
    k = 0;
    while(k<16) do
        [(UAPage+1)*512 -16 +k] = -1;
        k = k+1;
    endwhile;

    // Library
    [PTBR + 0] = 63;
    [PTBR+1] = "0100";
    [PTBR+2] = 64;
    [PTBR+3] = "0100";

    multipush(R0,R1,R2,R3,R4);
    R1 = 1;
    R2 = [SYSTEM_STATUS_TABLE + 1];
    call MEMORY_MANAGER;

    [ PTBR + 4 ] = R0;
    [ PTBR + 5 ] = "0110";

    R1 = 1;
    R2 = [SYSTEM_STATUS_TABLE + 1];
    call MEMORY_MANAGER;
    [ PTBR + 6 ] = R0;
    [ PTBR + 7 ] = "0110";

    R1 = 1;
    R2 = [SYSTEM_STATUS_TABLE + 1];
    call MEMORY_MANAGER;
    [ PTBR + 16 ] = R0;
    [ PTBR + 17 ] = "0110";

    R1 = 1;
    R2 = [SYSTEM_STATUS_TABLE + 1];
    call MEMORY_MANAGER;
    [ PTBR + 18 ] = R0;
    [ PTBR + 19 ] = "0110";

    multipop(R0,R1,R2,R3,R4);

    alias file_size R6;
    file_size = [INODE_TABLE + i*16 + 2]/512;

    if([INODE_TABLE+ i*16 + 2]%512 != 0) then
        file_size = file_size + 1;
    endif;

    alias j R7;
    j = 0;
    while( j < file_size ) do
        multipush(R0,R1,R2,R3,R4,R6,R7);

        R1 = 1;

        call MEMORY_MANAGER;

        multipop(R1,R2,R3,R4,R6,R7);

        multipush(R0,R1,R2,R3,R4,R6,R7);
        R1 = 2;
        R2 = [SYSTEM_STATUS_TABLE + 1];
        R4 = [INODE_TABLE + i*16 + 8+j]; // block number
        R3 = R0;                         // page number   
        
        call DEVICE_MANAGER;
        multipop(R0,R1,R2,R3,R4,R6,R7);
        // loadi(R0,[INODE_TABLE + i*16 + 8+j]);
    
        [PTBR + 8 + j*2] = R0;
        [PTBR + 8 + j*2 + 1] = "0100";
        
        multipop(R0);
        j = j+1;

    endwhile ;

    PTLR = 10;

    [[PTBR+16]*512] = [[PTBR + 8]*512 + 1];

    SP = 8*512;
    
    [PROCESS_TABLE + currentPID*16 + 9] = 0;
    ireturn;

endif ;