// module 1

alias functionNum R1;
alias currentPID R2;
alias userAreaPage R3;


// get pcb entry
if(functionNum == 1) then
    alias i R4;
    i = 0;
    // loop through process tables to find a free one
    while(i<16) do
        if([PROCESS_TABLE + i*16 + 4] == TERMINATED) then
            [PROCESS_TABLE + i*16 + 4] = ALLOCATED;
            [PROCESS_TABLE + 16*i + 1] = i;
            [PROCESS_TABLE + 16*i + 14] = PAGE_TABLE_BASE + 20*i;
            [PROCESS_TABLE + 16*i + 15] = 10;
            R0 = i;
            return;
        endif;
        i = i+1;
    endwhile;
    R0 = -1;
    return;
endif;

// free User Area Page
if(functionNum == 2) then
    userAreaPage = [PROCESS_TABLE + R2*16 + 11];

    alias i R4;
    i = 0;

    while ( i < 16 ) do
    
        if ( [([PROCESS_TABLE + currentPID*16 + 11]+1)*512 -16 + i] == 1) then
            
            // release semaphore 
            multipush(R1,R2,R3,R4);
            R1 = 7;
            R2 = [([PROCESS_TABLE + currentPID*16 + 11]+1)*512 -16 + i + 1];
            R3 = [SYSTEM_STATUS_TABLE + 1]; 
            call RESOURCE_MANAGER;
            multipop(R1,R2,R3,R4);

        endif;

        if ( [([PROCESS_TABLE + currentPID*16 + 11]+1)*512 -16 + i] == 0) then
            
            // release file 
            multipush(R1,R2,R3,R4);
            R1 = 4;
            R2 = [([PROCESS_TABLE + currentPID*16 + 11]+1)*512 -16 + i + 1]; 
            call FILE_MANAGER;
            multipop(R1,R2,R3,R4);
            
        endif;
        i = i + 2;
    endwhile;
    multipush(R1,R2,R3);

    R1 = 2;
    R2 = userAreaPage;
    call MEMORY_MANAGER;

    multipop(R1,R2,R3);

    return;
endif;

// exit
if( functionNum == 3 ) then

    // Free Page Table
    multipush(R1,R2);
    R1 = 4;
    call PROCESS_MANAGER;

    // Free UAPage
    R1 = 2;
    call PROCESS_MANAGER;

    multipop(R1,R2);

    if ([PROCESS_TABLE + [SYSTEM_STATUS_TABLE  + 1]*16 + 9] != 9) then
        alias i R4;
        i = 1;
        while( i<16 ) do
            if( [PROCESS_TABLE + i*16 + 4] == WAIT_PROCESS &&  [PROCESS_TABLE + i*16 + 5] == [SYSTEM_STATUS_TABLE + 1]) then
                [PROCESS_TABLE + i*16 + 4] = READY;
            endif ;

            if([PROCESS_TABLE + i*16 + 2] == [SYSTEM_STATUS_TABLE + 1]) then
                [PROCESS_TABLE + i*16 + 2] = -1;
            endif;

            i = i+ 1;
        endwhile;
    endif;

    [PROCESS_TABLE + currentPID*16 + 4] = TERMINATED;
    return;
endif ;

// Free page table
if( functionNum == 4) then
    
    // heap 1
    if([DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +2] != -1) then
        multipush(R0,R1,R2,R3,R4);

        R1 = 4;
        R2 = [DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +2];
        R3 = [SYSTEM_STATUS_TABLE + 1];

        //call release block
        call MEMORY_MANAGER;
        multipop(R0,R1,R2,R3,R4);
        [ DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +2] = -1;
    endif;

    // heap 2
    if([DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +3] != -1) then
        multipush(R0,R1,R2);

        R1 = 4;
        R2 = [DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +3];
        R3 = [SYSTEM_STATUS_TABLE + 1];

        //call release block
        call MEMORY_MANAGER;
        multipop(R0,R1,R2);
        [ DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +3] = -1;
    endif;

    // stack 1
    if([DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +8] != -1) then
        multipush(R0,R1,R2);

        R1 = 4;
        R2 = [DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +8];
        R3 = [SYSTEM_STATUS_TABLE + 1];

        //call release block
        call MEMORY_MANAGER;
        multipop(R0,R1,R2);
        [ DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +8] = -1;
    endif;

    // stack 2
    if([DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +9] != -1) then
        multipush(R0,R1,R2);

        R1 = 4;
        R2 = [DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +9];
        R3 = [SYSTEM_STATUS_TABLE + 1];

        //call release block
        call MEMORY_MANAGER;
        multipop(R0,R1,R2);
        [ DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +9] = -1;
    endif;

    // free disk map table
    alias k R4;
    k = 2;
    while( k<10 ) do
        [DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +k] = -1;
        k = k + 1;
    endwhile ;


    [PTBR + 0] = -1;
    [PTBR + 1] = "0000";
    [PTBR + 2] = -1;
    [PTBR + 3] = "0000";

    alias i R3;
    i = 4;
    while( i<20 ) do
        if([PTBR + i] != -1) then

            multipush(R1,R2,R3);
            // Release Page
            R1 = 2;
            R2 = [PTBR + i];
            call MEMORY_MANAGER;
            multipop(R1,R2,R3);
            
            [PTBR + i] = -1;
            [PTBR + i + 1] = "0000";

        endif;
        i = i+2;

        // multipush(R1, R2, R3);
        // R1 = 2;
        // R2 = [PTBR + i];
        // call MEMORY_MANAGER;
        // multipop(R1, R2, R3);

        // [PTBR + i] = -1;
        // [PTBR + i + 1] = "0000";
        // i = i + 2;
    endwhile ;
    return;

endif;