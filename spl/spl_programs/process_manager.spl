// module 1

alias functionNum R1;
alias currentPID R2;
alias userAreaPage R3;


// get pcb entry
if(functionNum == 1) then
    alias i R4;
    i = 0;
    // loop through process tables to find a free one
    while(i<16) do
        if([PROCESS_TABLE + i*16 + 4] == TERMINATED) then
            [PROCESS_TABLE + i*16 + 4] = ALLOCATED;
            [PROCESS_TABLE + 16*i + 1] = i;
            [PROCESS_TABLE + 16*i + 14] = PAGE_TABLE_BASE + 20*i;
            [PROCESS_TABLE + 16*i + 15] = 10;
            R0 = i;
            return;
        endif;
        i = i+1;
    endwhile;
    R0 = -1;
    return;
endif;

// free User Area Page
if(functionNum == 2) then
    userAreaPage = [PROCESS_TABLE + R2*16 + 11];
    multipush(R1,R2,R3);

    R1 = 2;
    R2 = userAreaPage;
    call MEMORY_MANAGER;

    multipop(R1,R2,R3);

    return;
endif;

// exit
if( functionNum == 3 ) then

    // Free Page Table
    multipush(R1,R2);
    R1 = 4;
    call PROCESS_MANAGER;

    // Free UAPage
    R1 = 2;
    call PROCESS_MANAGER;

    multipop(R1,R2);
    [PROCESS_TABLE + currentPID*16 + 4] = TERMINATED;

    return;
endif ;

// Free page table
if( functionNum == 4) then
    
    // heap 1
    if([DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +2] != -1) then
        multipush(R0,R1,R2,R3,R4);

        R1 = 4;
        R2 = [SYSTEM_STATUS_TABLE + 1];
        R3 = [DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +2];

        //call release block
        call MEMORY_MANAGER;

        multipop(R0,R1,R2,R3,R4);
    endif;

    // heap 2
    if([DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +3] != -1) then
        multipush(R0,R1,R2);

        R1 = 4;
        R2 = [SYSTEM_STATUS_TABLE + 1];
        R3 = [DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +3];

        //call release block
        call MEMORY_MANAGER;

        multipop(R0,R1,R2);
    endif;

    // stack 1
    if([DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +8] != -1) then
        multipush(R0,R1,R2);

        R1 = 4;
        R2 = [SYSTEM_STATUS_TABLE + 1];
        R3 = [DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +8];

        //call release block
        call MEMORY_MANAGER;

        multipop(R0,R1,R2);
    endif;

    // stack 2
    if([DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +9] != -1) then
        multipush(R0,R1,R2);

        R1 = 4;
        R2 = [SYSTEM_STATUS_TABLE + 1];
        R3 = [DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +9];

        //call release block
        call MEMORY_MANAGER;

        multipop(R0,R1,R2);
    endif;

    // free disk map table
    alias k R4;
    k = 2;
    while( k<10 ) do
        [DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 1]*10 +k] = -1;
        k = k + 1;
    endwhile ;


    [PTBR + 0] = -1;
    [PTBR + 1] = "0000";
    [PTBR + 2] = -1;
    [PTBR + 3] = "0000";

    alias i R3;
    i = 4;
    while( i<20 ) do
        if([PTBR + i] != -1) then

            [PTBR + i] = -1;
            [PTBR + i + 1] = "0000";
            multipush(R1,R2,R3);

            // Release Page
            R1 = 2;
            R2 = [PTBR + i];
            call MEMORY_MANAGER;
            multipop(R1,R2,R3);

        endif;
        i = i+2;

        // multipush(R1, R2, R3);
        // R1 = 2;
        // R2 = [PTBR + i];
        // call MEMORY_MANAGER;
        // multipop(R1, R2, R3);

        // [PTBR + i] = -1;
        // [PTBR + i + 1] = "0000";
        // i = i + 2;
    endwhile ;
    return;

endif;